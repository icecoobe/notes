# data encoding

## Sign Magnitude

书本中翻译为`原码`，直译过来是有符号的量，也是最自然的表示方式，符合人的思维。
当用计算机表示数值的时候，我们首先想到将+-符号用单独一个bit来存储：0表示`+`，1表示`-`。

正数还是其本身的二进制表示方式，负数则使最高位为1，其余部分与其正数部分一致。

示例：对于八位的数值1

- 1: 0000 0001B
- -1: 1000 0001B

## Ones' Complement

书本中翻译为`反码`，直译过来的是一个1或者多个1的补集

对于一个正数x，其反码还是本身；
对于负数-x，其用反码表示为 1111·····1 - x

示例：对于八位数的1

- 1: 0000 0001B
- -1: 1111 1111B - 0000 0001B = 1111 1110B
可能是因为负数的表示方式刚好是将正数的每一位都进行取反`~`操作，因此将其翻译为反码。

> 备注：`Complement` 表示不可或缺的补充，有互补，更完善和互相依存的意思；同义的`Supplement`则是额外补充的意思，不是不可或缺的

## Two's Complement

翻译为补码，直译过来是2的补集。
对于一个正数x，其补码表示为它的原码。
对于一个负数-x，采用N个bits来存储时，其补码表示为2^N - x
它恰好包含了原码的符号特点，也可以采用加法进行所有的数值计算。之前一直不知道这一块的数学原理，后来发现它利用了数学上模运算取余的机制。
引入补码的目的是为了避免使用反码原码时0的两种表示方式带来的歧义和处理问题。

0的原码：

- 0000 0000B
- 1000 0000B

0的反码：

- 0000 0000B
- 1111 1111B

还有就是当初设计计算机时只实现了加法器，如果再引入减法器会额外增加更多的电路复杂性。还有就是在计算时要额外处理符号位，这也是增加了电路的复杂性。

因此，人们巧妙的利用了计算机不能表示无穷大的数，只能表示一定范围的数，当表示超出范围的数时会有溢出，也就是超出部分会丢失这个特点，来设计了补码。

TODO：
1000 0000B 代表多少

```cpp
signed char i = 0B1'0'00'0000;
printf("%i, \n", i);
// -128
```

- 可以使用`0B`前缀直接以二进制形式来定义数据。
- 使用`'`来分割二进制序列，它可以出现在`0B`和第一个数字之后的任意位置。

### 补码的计算

针对补码求其值，只需要将正负位的权重值的和计算出来即可。
比如，8位的数1000 0001B等于

``` math
2^(7) * (-1) + 1 = -127
```

对于一个w位的整数，正数为x，那么-x的补码为

``` math
2^w - x
```

这可能是补码英文原名的意义所在。

#### 数值范围

- 对于无符号数，w位的整数范围是0-(2^w-1), 可以表示2^w个数
- 对于有符号数，w位的整数范围是(-2^(w-1)) - (2^(w-1) - 1), 可以表示2^w个数
负数根据补码的权重计算方式，当正权重的位都是0，负权重位为1时，得到w位数据最小的负数 -2^(w-1)。

所以，8位的有符号数，最小的负数是-2^7 = -128，最大的正数是2^7 - 1 = 127，再加上0，一共是128 + 127 + 1 = 256个数。

### TODO

验证溢出的处理，比如-128 + (-128), 127+127

``` c
    char a = -128;
    char b = 127;
    char result = (char)(a + a);
    printf("%d, %d\n", result, a+a);

    result = b + b;
    printf("%d, %d\n", result, b + b);

    result = b + 1;
    printf("%d, %d\n", result, b + b);
```

输出

``` console
0, -256
-2, 254
-128, 254
```
