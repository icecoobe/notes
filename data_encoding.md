# data encoding

## Sign Magnitude

书本中翻译为`原码`，直译过来是有符号的量，也是最自然的表示方式，符合人的思维。
当用计算机表示数值的时候，我们首先想到将+-符号用单独一个bit来存储：0表示`+`，1表示`-`。

正数还是其本身的二进制表示方式，负数则使最高位为1，其余部分与其正数部分一致。

示例：对于八位的数值1

- 1: 0000 0001B
- -1: 1000 0001B

## Ones' Complement

书本中翻译为`反码`，直译过来的是一个1或者多个1的补集

对于一个正数x，其反码还是本身；
对于负数-x，其用反码表示为 1111·····1 - x

示例：对于八位数的1

- 1: 0000 0001B
- -1: 1111 1111B - 0000 0001B = 1111 1110B
可能是因为负数的表示方式刚好是将正数的每一位都进行取反`~`操作，因此将其翻译为反码。

> 备注：`Complement` 表示不可或缺的补充，有互补，更完善和互相依存的意思；同义的`Supplement`则是额外补充的意思，不是不可或缺的

## Two's Complement

翻译为补码，直译过来是2的补集。
对于一个正数x，其补码表示为它的原码。
对于一个负数-x，采用N个bits来存储时，其补码表示为2^N - x
它恰好包含了原码的符号特点，也可以采用加法进行所有的数值计算。之前一直不知道这一块的数学原理，后来发现它利用了数学上模运算取余的机制。
引入补码的目的是为了避免使用反码原码时0的两种表示方式带来的歧义和处理问题。

0的原码：

- 0000 0000B
- 1000 0000B

0的反码：

- 0000 0000B
- 1111 1111B

还有就是当初设计计算机时只实现了加法器，如果再引入减法器会额外增加更多的电路复杂性。还有就是在计算时要额外处理符号位，这也是增加了电路的复杂性。

因此，人们巧妙的利用了计算机不能表示无穷大的数，只能表示一定范围的数，当表示超出范围的数时会有溢出，也就是超出部分会丢失这个特点，来设计了补码。

TODO：
1000 0000B 代表多少


### 补码的计算

针对补码求其值，只需要将正负位的权重值的和计算出来即可。
比如，8位的数1000 0001B等于
2^(7) * (-1) + 1 = -127